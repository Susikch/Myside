# Myside
- git add . - добавляет изменения файла
- git status -  даёт понимание, какие файлы были изменены, добавленны или удалены. Но не сделанн коммит
- git commit -m "Changes description" - фиксирует изменения в репозитории. Сохраняет их в историю, в которую можно обратиться
- git log - выводит всю историю коммитов. кто что когда изменил
- git show - выводит инфу о определённом коммите
- git diff - разница между текущими изменен и последним коммитом. Показывает что именно изменилосьв файлах
- git restore - отменяет все изменения в файлах, возвращает в состояние последнего коммита
- git rm - удаляет файлы из git, а так же из рабочей папки в случае необходимости
- git reset - отменяет все коммиты и возвращает проект к более раннему этапу
- git branch - показ список веток
1 git branch new branch name - создаёт новую ветку
2 git branch -d "branch name" - удаляит веткус названием
- git pull - переносит актуальные изменения с гита на наш репозиторий. Желательно находиться на главной ветке в момент выполнения
- git push - отправляет изменения в удалённый репозиторий (работ только после коммита)
- git help - показывает все доступные комманды git
- git clone url - скопир репозиторий с гита

т.1 - понятия репозитория и структура проекта
репозиторий - хранилище кода, включающее: 1. все файлы и папки проекта 2. историю изменений (коммиты) 3. инфа о ветках и настройках
виды репозиториев: 1. локальный - храниться на компе дева (папка .git) 2. удалённый (remote) - размещён на сервере (github, gitlab)

### Структура проекта

project/        # Корневая папка проекта
|—— .git/       # 
| 
|—— src/        # Исходный код
|—— docs/       # Документация
|—— tests/      # Тесты (unit-тесты, интеграционные тесты)
|—— config/     # Файлы конфигурации
|—— assets/     # Ресурсы (изображения, шрифты, др.)
|
L—— gitignore/  # Файл, указывающий, какие файлы Git должен игнорировать

Основные элементы:
    - .git/ —
    - README.md
    -

# Жизенный цикл файлов в Git
    1. Неотслеживаемые - Git о них не знает
    2. Измененные - файлы, которые уже в репозитории, но были изменены
    3. Индексируемые - файлы, которые подготовлены к коммиту
    4. Зафиксированные - файлы, которые сохранены в репозитории

# Важные правила
    - .gitignore обязателен, чтобы не засорять проект лишними файлами
    - README.md обязателен, это лицо проекта. В нем должно быть описание, инструкция к установке и использованию

управ учёт данными
-учёт данные виндоус
-удаление учётных данных по гитхабу



т.2 Биды цели и уровни интеграции программных модулей
Понятие интеграции программ модулей – процесс объединения отдельных компонентов по в единую систему которая обеспечивает их совместное функционирование
Цель интеграции:  1. Обеспечение взаимодействие модулей
2. повышение надёжности и производительности системы
3. упрощение разработки и сопровождение по
4. минимизация дублирования функционала
Виды интеграций прог мод:
1. По способу взаимодействия
- горизонтальная интеграция – объединение модулей 1ого уровня (например взаимодействие между сервисами в микро сервисной архитектуре)
- вертикальная интеграция – объединение модулей разных уровней (например клиент серверное взаимодействие)
2. По степени связанности
- слабая связанность – модули взаимодействуют через стандартные интерфейсы (АПИ и сообщения) что упрощает замену компонентов (пример РестфулАПИ и микросервисы)
-сильная связанность – модули тесно зависят друг от друга, изменения одного модуля требует модификации других (пример монолитная архитектура)
3. По времени выполнения
- статическая интеграция – компоненты связываются на этапе компиляции (пример с++)
- динамическая интеграция – компоненты связываются во время выполнения (пример плагины в рантайме)
4. По уровню автоматизации
- ручная интеграция – разраб сам настраивает взаимод модулей меж собой
-автоматизированная интеграция – исп сиай\сидип и система сборки
Уровни интеграции
1. Уровень данных – на уровне данных инт осуществляется через общие базы данных, файлы или очереди сообщений (пример скл БД майскл помтгрескл блокеры сообщенй рабитмк)
2. Уровень АПИ – сервисный уровень, модули взаимодей через АПИ (рест графкьюэль). (пример веб сервисы и микросервисная архитектура)
3. Уровень юай – интеграция происходит через единый интерфейс (веб, мобильные приложения (пример спа и пва)) 
4. Уровень бизнес логики – интеграция на уровне бизнес правил и процессов (ерп системы и варпфлоу движки)

Инструментальные стредства интеграции
1. средства сборки и управление зависимостями
- maven gradle
-npm yarn
-pip
2. Ci\ CD инструменты
-jenkins gitlab github – автоматизация сборки и тестирование
-docker kubernetes – контейнеризация и оркестрация
3. middleware и брокеры сообщений
-rabbitmq, apache kafka – асинхронная интеграция
-redis  кеширование и паб\ саб
4. api шлюзы и сервисные сетки
-kong, apigee – управ апи
-istio, linkerd – сервис меш для микросерверов

Автоматизация бизнес-процессов – исп различных технологий для повторяющихся задач. Подразум минимизацию ручного труда и повыш эффективности работы организации
Цели автоматизации:
- ускорение выполнения операций
- снижение ошибок
-оптимизация затрат
-повышение управляемости и прозрачности процессов
-масштабирование процессов
Виды бизнес процессов
-линейные (простые) процессы – подраз послед задачи без ветвлений
-нелинейные (сложные) процессы – циклы и параллел потоки
Финансы и бухгалтерия
Логистика и склад
Эйчар процесс
Уровни автоматизации бизнес проц
- базовый уровень – базовая автоматизация, генерация отчётов
- средний уровень – воркфлоу автоматизация, биэрэм системы
- высокий уровень – рпа

Ии
Инструментальные средства для автоматизации
1.	Low code\ no code платформы
-microsoft point automate- интеграция сервисов без программирования
-zapier- связь между веб приложениями
-notion + automate.io- управ проектами
2. bpm системы
-camunda- опен сурс для модел процессов
-bizagi- визуал дизайнер
-appian, pega- кооерат платформы
3. rpa инструменты
-uipath- разраб програм роботов
-utomation anywhere- облач авториз
4. интеграционные системы
-apache kafka- поток обраб данных
-mulesoft- апи интеграция



### конфиг преттер

форматировать док: shft + alt + f
{
# Макс кол-во символов на 1 строке
    "printwidth": 80,
# использовать символы табуляции для отступов
    "useTabs": true,
# ширина отступа при табуляции, колво пробелов
    "tabsWidth": 2,
# использовать ; в конце выражений жаваскрипт
    "semi": true,
# использовать одинарные ковычки или двойные
    "singleQuote": true,
# правило подстановки завершающей запятой
    1 none - не добавлять финульную запятую
    2 es5 - добавить запятую там где это допустимо
    3 all - везде где синтаксис позволяет
    "traillingComma": "es5",

# оставлять пустое пространство внутри квадрат или круг скобках
    "bracketSpacing": true,
# включать ли аргументы функции в круг скобки
    1 always - всегда
    2 avoid - избегать круг скобок при 1 аргументе
    "arrowParents": always,
}


т.3 Выбор источников и приёмников данных. Сопостовление объектов данных
источник данных - объект или система, откуда поступают данные для обработки данных
приёмник данных - объект или система, куда передаются обработанные данные

примеры источников: бд, скл, носкл, файлы, апи

потоки данных

примеры приёмников: бд (запись результ), отчёты и визуализации, внешние системы, облачные хранилища

критерии выбора источников и приёмников:при выборе учитывают
-формат данных
 структурированных
 полуструктурированный
 неструктурированный
-объём данных большие данные требуют распределённых систем
-частота обновления (риалтайм, пакетная обработка)
-надёжность и доступность
-безопастность (шифрование)
-стоимость

сопостовление объектов данных - проц преобраз данных мужду источником и приёмником

этапы сопостовления
1 анализ структуры данных - сравнение полей в источнике и приёмнике
2 преобразование гипоф - строку, дату
3 маппинг полей - сопостовление названий столбцов
4 обработка отсутствующих данных - при отсутствии данных поля заполняются либо дефолт знач, либо явно указанными
5 валидация - проверка на корректность


1 несовпадение схем - реш униф форматом
2 потери данных - реш логированием и мониторингом
3 производительность - оптимиз запросы, индексы и реализ кеширование

транспортные протоколы, стандарты формирования сообщений
тран просток определ правило передач данных меж систем

основ транс проток:
1 хттп - хипер текст трансфер протокол
  хттп(с) - + секюр

2 веб сокет
двухсторонний протокол для обмена сообщениями
+ - низкие задержки, постоянный актив
исп в играх

3 тсп ап и юдп
трансмисс контрол протокол - надёжная предача
исп в хттп

юзер дата протокол - быстр передача без гарантии доставки
исп в ВоИП

4 мкьютт
месседж кьюери телеметри транспорт
легковесный протокол
паб саб модели

5 амкьюп
протокол для асинхронного обмена сообщениями
раббитМК кафка

6 грпк
высокопроизводительный рпс протокол